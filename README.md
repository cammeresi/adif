# ADIF Parsing for Rust

[![CI](https://github.com/cammeresi/adif/workflows/Rust/badge.svg)](https://github.com/cammeresi/adif/actions)
[![codecov](https://codecov.io/gh/cammeresi/adif/branch/master/graph/badge.svg)](https://codecov.io/gh/cammeresi/adif)

## Overview

This crate parses [Amateur Data Interchange Format][adif] (ADIF) data using
asynchronous streams.

ADIF is a standard data format used by ham radio operators to exchange
information logged about past contacts.  This crate provides a few ways to
parse ADIF data in Rust on top of tokio.

[adif]: https://adif.org/

## Usage

Add the dependency:

```sh
cargo add TBD
```

Then start reading ADIF from any object that implements the AsyncRead trait:

```rust
use adif::RecordStream;
use futures::StreamExt;
use tokio::{fs::File, io::BufReader};

#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file = File::open("examples/sample.adif").await?;
    let reader = BufReader::new(file);
    let mut stream = RecordStream::new(reader, true);
    while let Some(result) = stream.next().await {
        let record = result?;
        if let Some(call) = record.get("call") {
            println!("call: {}", call.as_str());
        }
    }
    Ok(())
}
```
See examples or documentation for further information.

## Features

Because there is some variety to the ADIF fields generated by various
programs, the data reader usually needs to engage in some interpretation
of the data based on its source.

This parser is intended to be maximally flexible and provide the user
with parsed ADIF data from any source at any level with or without
preprocessing.

Input is read from a stream.  File input is not assumed.  Reading an
entire file is not assumed; it's fine to start in the middle.  Trailing
data in the form of a partial tag or record can be ignored or return an
error.  Leading text is ignored.

The code in this crate strives to be panic-free, extremely safe, and
lightweight in terms of memory usage.  (There is a single line of unsafe
code in [`CiStr::new`] that transmutes references from a `&str` to a
transparent wrapper type.)

## Components

The [TagStream] provides the lowest level of output:  individual ADIF
tags and their associated values.  Values are parsed and are strongly
typed, although in the absence of type specifiers (which is common),
data can be coerced to the desired type when accessed.

The [RecordStream] provides higher level output by aggregating fields
into records, each representing one contact.  Records may then be indexed
into by key.

A number of data normalizers are provided in the [filter] module that
can be stacked on top of a [RecordStream] to automatically transform
records as they are read.  They are intended to be generally useful at
smoothing some of ADIF's roughest edges, but they are not necessarily
every single transformation an application might desire.  The user can,
however, write additional normalizers to implement additional
transformations not heretofore envisioned by the author.

## Testing

Testing is expected to be extreme.  Code coverage is expected to be in
excess of 99%.

As of 2025-11-21, test coverage is 100%.

Every single function, every single line, and every single expression
in the entire crate is executed by at least one test.  This fact is
verified by both `cargo llvm-cov` and codecov.io (badge at top).

The report from `cargo llvm-cov` contains a few exceptions in its summary
data only (5 out of over 3900 regions), but it does not positively
identify any expression in this crate that is not executed by a test.
These anomalies may be small bits of code from the standard library
that are inlined by the compiler and that are thus out of the control
of this crate.

> I reviewed your flight plan.  Not one error in a million keystrokes.
> Phenomenal.  [[Gattaca, 1997][gattaca]]

[gattaca]: https://en.wikipedia.org/wiki/Gattaca

Additionally, each of the property-based tests has run over one million
times without error.

## Author

Sidney Cammeresi, AB9BH

